# 0.1 Maqsad, Modellashtirish va Simulyatsiya

## 0.1.0 Kirish

"Me'yor" dasturiy ta’minot tuzilishini uch asosiy yo'nalishda ifodalaydi: Maqsad, Modellashtirish va Simulyatsiya. Ularning har biri muhandislarning muvaffaqiyatli yechim va aniq maqsadga erishishlarida muhim rol o'ynaydi. Bu yo'nalishlarning bajarilish ketma-ketligi ham o'zaro bog'liqdir. Maqsadning aniq bo'lishi modellashtirish jarayonida katta ahamiyat kasb etadi. Ayni paytda simulyatsiya jarayoni ham modellarsiz bajarila olmaydi. Bunday ketma-ketlik muhandislik faoliyati boshlanishida hal qiluvchi ma’no kasb etsada, shuni anglash kerakki, jarayonning o'zi tanlab takrorlanadi. Maqsaddagi o'zgarish simulyatsiyada o'z aksini topishi mumkin, ammo model o'zgartirishini taqazo qilmasligi mumkin. Modeldagi o'zgarish na maqsad va na simulyatsiyani jarayoni o'zgartirmasligi ham mumkin.

![Theory Diagram](Resurslar/Maqsad%2C%20Modellashtirish%20va%20Simulyatsiya/maqsad%2Cmodellashtirish%20va%20simulyatsiya.png)


## 0.1.1 Maqsad

Maqsad qo'yish jarayoni - nima uchun bizga yechim kerakligini aniqlash qobiliyatidir. Misol uchun, ma'lum bir oziq-ovqat do'kon javonida qancha mahsulot borligini bilish bilan bog'liq muammo bor. Biz qo'lda hisoblash jarayonini samarasiz deb hisoblaymiz va mahsulotlarni to'g'ri hisoblashimiz uchun tizimni joriy qilish kerak.

Mulohaza yuritish ko'p jihatdan muammolarni kuzatish va keyin ushbu muammoni hal qiladigan yechimni ishlab chiqish uchun muammoni ifodalash qobiliyatiga bog'liq. Loyihaning maqsadini aniqlash bu harakatni boshlash uchun sabab topishdir.

Shunday qilib, biz kuzatdik, muammoni mohiyatini tushundik va yechimni ishlab chiqish uchun maqsadga ega bo'ldik. Bu jihatlarning barchasi muhandislik dasturiy ta'minotining Maqsadlashtirish qismini tashkil qiladi.

## 0.1.1.0 Kuzatish

Kuzatuvlarga to'la dunyoda yashaymiz. Kattaroq narsalarga erishishga bo'lgan istagimiz bizni ilhomlantiradi. Orzularimiz oldimizda turgan to'siqlarni bizga ko'rsatadi va ularga erishishimiz va safarimizda davom etishimiz uchun bu muammolarni hal qilishimiz kerak. Bu yosh talaba murakkab tenglamalarni yechish uchun kalkulyatorni qo'lga olgan paytdan boshlab, astronavt bo'lib yer shari uzra parvoz qilayotgan sun'iy yo'ldoshlarni harakat trayektoriyasini hisoblayotgan davrgacha, barcha harakatlar muammoni hal qilishni taqazo qiladi. 

Tadqiq qilish jarayoni- orzuyimizga erishishga to'sqinlik qilayotgan muammolarni aniqlash qobiliyatidir. Muammolar oziq-ovqat do'konidagi yemaklarning javondagi miqdoridan  tortib, million yillar uzoqlikdagi sayyoralarni rasmga olish imkoniyatimiz cheklanganligining sabablarini o'rganishgacha qamrab oladi. Bu muhandislar tili bilan aytganda, tadqiq qilish mumkin bo'lgan muammolardir. 

Maqsad qanchalik katta bo'lsa, muammo ham shunchalik murakkab bo'ladi. Kichikroq maqsadlardan boshlash miyamizni kattaraq muammolarni hal qilishga bosqichma-bosqich tayyorlovdir. 

## 0.1.1.1 Ifoda etish

Tadqiqotni ifoda qilib bera olishning o'zi bir san'atdir, chunki muammoni to'g'ri ifoda etish uni hal qilishning yarmidir. Muammoni ifodalanishi qanchalik aniq bo'lsa, uni hal qilishda yordam beruvchilarning tushunishi shuncha oson bo'ladi.


Ifoda etish doim so'zlar bilan bo'lmaydi: chizma va shakllar bilan ham bo'lishi mumkin. Qadimiy millatlar o'z davri va tarixini tasvirlash uchun chizmalardan foydalangani bejizga emas. Chizmalar umumbashariy tildir, nutqni o'rganishdan ko'ra unga bog'lana olganlar uchun tushunish va tarjima qilish ancha osonroqdir. Chizma yoki rasm g'oyani tushuntirishni eng samarali usulidir, zero aytilganki: "Ming eshitgandan, bir ko'rgan yaxshi", - deb. 

Ifoda etish muammoni hal qilish uchun ishtiyoq bo'lishini talab qiladi:u xoh yozma, xoh og'zaki yoki chizilgan holda bo'lsin. Qiziqishga ega insonning miyasi avtomatik holda hal qilinishi kerak bo'lgan murakkab muammoning  yashirin mohiyatini anglay oladi. Muammoni aniq ifoda eta olish- bir kishi yechim sota olishining asosiy qismidir. Muammoni muhandislar, investitsiya kiritadigan va yechimni ishlatadigan insonlarga ifoda qilib bera olish qobiliyati loyihalar yaratishning eng muhim jihatlaridan biridir.

## 0.1.1.2 Yechim Izlash

Maqsadning yakuniy qismi unga erishish yo'llarini izlashdir. Muhandislik sohasida, maqsadlarga shunchaki erishib bo'lmaydi. Dunyo bo'ylab ko'plab dasturlar muvaffaqiyatga erisha olmasligining asosiy sababi -maqsad qo'yish jarayonida- ma'lum muammoga yechim berishning  e'tibordan chetda qolganligidir. Maqsadga erishish yo'lida qo'yilgan muddatni o'tkazib yubormaslik uchun qisqa yo'l izlab qoladigan dasturchilar haqida eshitgandirsiz. Bu bizning Me'yorga zid amaliyotdir. Yechim faqatgina niyatga erishtiribgina qolmay, samaradorlik, o'qiy olishlik, ulana olishlik va davomiylik kabi arxitekturaviy talablarni ham qondirish maqsadini ko'zda tutgan bo'lishi kerak. Maqsadning bir qismi o'laroq, yechim bera olishlik haqiqiy muhandislik hunaridir. 


## 0.1.2 Modellashtirish

Modellashtirish muhandislikning ikkinchi eng muhim bosqichidir. Har qanday muammoda qatnashuvchilardan modellar ajratib olishimiz mumkin, u qatnashuvchilar xoh tirik jonlar xoh boshqa obyektlar bo'lsin. Bu jarayonda muammoni yechish uchun kerak bo'ladigan xossalarni aniqlash va keraksizlarini qoldirish ham mumhim. Misol uchun, oziq-ovqat do'konidagi mahsulotlarni sanashga urinayotganimizda, ularning har biri uchun model yaratishimiz kerak bo'ladi. 

Yanada aniqroq misol, muddati o'tadigan mahsulotlarning aniqlash bo'lishi mumkin. Mahsulotdagi saqlash muddati bizga kerakli bo'lgan yagona ma'lumotdir. Nomi, rangi, vazni yoki har qanday boshqa ma'lumoti yechim taqdim qilish va modellashtirish jarayoni uchun ahamiyat kasb etmaydi. 

Modellarni maqsadsiz yaratib bo'lmaydi. Maqsad modellarning qanday bo'lishini aniqlab beradi. Aniq maqsadsiz modellashtirish koinotda mavjud barcha xossalarni modelda jam qilishga urunishga sabab bo'lishi mumkin. 

Maqsad va modelning murakkabligi to'g'ri proporsionaldir. Ya'ni, maqsad qanchalik murakkab bo'lsa, modellashtirish jarayoni yechim taqdim qilayotganda real hayotimizdan ko'proq ma'lumotlarni modelda jam qilishni talab qiladi.

Modelni dasturlash tillarida `class` ifodalay olamiz. Oldin aytib o'tilgan muddati o'tayotgan mahsulatning muammosini quyidagi class orqali hal qilishimiz mumkin bo'ladi:

``` cs

public class Mahsulot
{
	public DateTimeOffset YaroqlilikMuddati {get; set;}
}

```

Classning nomi barcha do'kondagi barcha narsalarni umumiylashtiradi. Chunki barcha buyumlar yaroqlilik muddati bo'lgani uchun, nomi iloji boricha umumiy bo'lib qoladi. 

Tasavvur qiling maqsadni biroz kengaytirdik. Unga kora, endilikda yaroqlilik muddati kam qolgan mahsulotlarni aniqlab berish muammosi o'rtaga tashlandi, shu tarzda xodimlar ularni xaridorlarga osonroq ko'rinishi uchun old rastalarga joylashtirishlari mumkin bo'ladi. Bunday holatda, bizning model yangi Narx degan xossani kompyuter qaysi mahsulot qimmatroq ekanini aniqlash uchun talab qiladi. Quyida yangi model qanday bo'lishi ko'rishingiz mumkin: 

``` cs
public class Mahsulot
{
	public double Narx {get; set;}
	public DateTimeOffset YaroqlilikMuddati {get; set;}
}
```

## 0.1.2.0 Model Turlari
Modellar muammoni va (uning yechimini) ifoda qilishda asosiy o'rin egallaydi. Modellar 3 ta asosiy kategoriyaga bo'linadi: Ma'lumot Tashuvchilar, Amaliyot Bajaruvchilar va Sozlamalar Tashuvchilar. 

### 0.1.2.0.0 Ma'lumot Tashuvchilar

Ma'lumot tashuvchilarning asosiy vazifasi sistemaning turli nuqtalariga ma'lumotni yetkazib turish.  Ular tashuvchi ma'lumotining turiga qarab farqlanishi mumkin. Ba'zi ma'lumot tashuvchilar murakkab sistemani namoyish qilish uchun boshqa modellarni ham o'zida saqlashi mumkin. Boshqalari esa asl ma'lumot tashuvchilarga ko'rsatgichlar (kalitlar)nigina saqlashi mumkin. 

Ma'lumot tashuvchi modellar uzviy bog'liq (relatsional - SQL strukturasiga asoslangan) ma'lumotlar ombori holatida 3 ga bo'lish mumkin. Shu yosinda muhandislik, loyihalashtirish va ishlab chiqish jarayonlarida qilinishi kerak bo'lgan vazifalarni afzalligi bo'yicha ketma-ketligini aniqlashtirishimiz mumkin. Misol uchun, asosiy model chetda qolib, 2-darajadagi/yordam beruvchi modellarni yarata olmaymiz. Keling har bir ma'lumot tashuvchi model turi haqida batafsil gaplashib o'tsak.

#### 0.1.2.0.0.0 Asosiy Modellar

Asosiy modellar har bir sistemaning ustunidir. Hech qanday sistemani asosiy modellarni aniqlashtirmasdan va qoralama qilmasdan loyihalash va ishlab chiqish bosqichiga o'tib bo'lmaydi. Misol uchun, maktab ishlarini boshqarish sistemasini tuzayotgan bo'lsak, O'quvchi (Talaba) yoki Fan kabi modellar asosiy model hisoblanadi.

Asosiy modellar (relatsional - SQL ga asoslangan sxemada) boshqa mavjud modellarga bog'liq bo'lmaydi. Boshqa modellardan mustaqil bo'lgani uchun ular asosiy model deb ataladi. Yanada soddaroq tushuntiradigan bo'lsam, maktab sistemasida Talaba modeli O'qituvchi modeliga bog'liq bo'lmagan holda ishlaydi. Bu majburiy bo'lmagan bog'liqlik deyiladi.

Lekin asosiy modellar ham mantiqan boshqa modellarga bog'liq bo'lishi mumkin. Misol uchun, Talaba modeli O'qituvchi modeliga mantiqan bog'liq, chunki O'qituvchisiz talaba bo'lishi mumkin emas. Bundan tashqari, Talaba modeli o'zining va uning yonidagi servislarga g'oyaviy bog'liq bo'lishi mumkin. Misol uchun, biznes g'oyani amalga oshirish uchun talaba modeli xabar berish modeli bilan birga ishlashi kerak bo'lishi mumkin. Ya'ni har qanday talaba xabarlar orqali vazifalar, darslar va tadbirlar haqida ushbu bo'limdan foydalanadi. 

#### 0.1.2.0.0.1 Ikkinchi Darajali Modellar

Ikkinchi darajali modellar asosiy modellarga bog'liq bo'ladi. Uzviy bog'liq (relatsional - SQL strukturasiga asoslangan) ma'lumotlar omborida, ular odatda umumiy sxemada boshqa modelga kalit orqali bog'lanadi. Lekin, hattoki, uzviy bog'liq bo'lmagan (relatsional bo'lmagan - SQL ga asoslanmagan) ma'lumot saqlash sistemalarida ham ikkinchi darajali modellar ma'lum model ichidagi model yoki majburiy bo'lmagan kalit orqali ulangan model ko'rinishida bo'lishi mumkin. 

Keling ba'zi misollar keltirib o'tamiz. Ijtimoiy tarmoq platformasida `Sharh` modelini `Post` modelisiz tasavvur qilib bo'lmaydi. Mavjud bo'lmagan narsa haqida sharh yozib qoldirolmaysiz. Uzviy bog'liq ma'lumotlar omborida, `Sharh` modeli quyidagicha ko'rinishi mumkin: 

![Theory Diagram](Resurslar/Maqsad%2C%20Modellashtirish%20va%20Simulyatsiya/0.0.2.0.0.png)


Yuqoridagi misolga ko'ra, ikkinchi darajali model (`Sharh`) `Post` modelidagi `Id` kalitini o'zida saqlaydi. Uzviy bog'liq bo'lmagan (relatsional bo'lmagan) sistemalarda, ikkinchi darajali modellar ichki obyekt ko'rinishda ko'zga tashlanadi. 

```json
{
	"id": "some-id",
	"tarkib": "some post",
	"sharhlar": [
		{
			"id": "comment-id",
			"tarkib": "some comment"
		}
	]
}
```

Ikkinchi darajali modellar umuman olganda ular yashayotgan, qo'shni bo'lgan yoki tashqi sistemalardagi modellar bilan mantiqiy va tasavvuriy bog'lanishlari bo'lishi mumkin. Lekin, ularning bunday bog'lanishga ega bo'lishlari ehtimoli Asosiy modellarga nisbatan juda past. 


#### 0.1.2.0.0.2 Bog'lanish Modellari 

Bog'lanish modellari ikki asosiy modellar bog'lovchisi hisoblanadi. Ularning asosiy vazifasi ikki model orasidagi murakkab tarkibli (many-to-many) munosabatni
ifodalaydi. Misol uchun, Talabaning bir nechta O'qituvchisi bo'lishi mumkin va O'qituvchining bir nechata Talabasi. Bu munosabatni ifoda etadigan alohida jadval yaratishimiz kerak. 

Bog'lanish modellarida hech qanday ma'lumot saqlash ko'zda tutilmagan. Boshqa-boshqa modellarning kalitini saqlaydi va bu uning kaliti hisoblanadi. Bu birlashgan kalit ikki yoki undan ko'p tashqi kalitlardan tashkil topadi. Quyidagi misolga e'tiboringizni qarating: 

![Theory Diagram](Resurslar/Maqsad%2C%20Modellashtirish%20va%20Simulyatsiya/0.0.2.0.2.png)

#### 0.1.2.0.0.3 Gibrid Modellar

Ham ma'lumot saqlab, ham boshqa jadval kalitlarini saqlaydigan modellar mavjud. Loyiha arxitekturasini sofligini saqlash va modellarning murakkabligini boshqarish uchun bunday modellardan uzoqda bo'lishni maslahat beraman. Lekin, ba'zan ma'lum biznes g'oyani amalga oshirish yoki aniq bir talabni qondirish uchun bundan boshqa chora qolmaydi. Bunday holatda, ikki mustaqil modelning munosabatidagi ba'zi ma'lumotlarni saqlashi uchun gibrid modellardan foydalanishimiz mumkin: 

![Theory Diagram](Resurslar/Maqsad%2C%20Modellashtirish%20va%20Simulyatsiya/0.0.2.0.3.png)

Gibrid modellar asosiy modellarning kalitlarini saqlash bilan birgalikda ikkinchi darajali modellarni o'z ichiga oladi. Ular uzviy bog'liqlik (relatsional) tabiatini alohida jadvalga chiqmay turib ifodalashadi. Uzviy bog'liq bo'lmagan ma'lumotlar omborida, kalit orqali bog'lanish talabi sxemaning chiziqli tabiati tufayli xatoliklarga olib kelmasligi mumkin. 


### 0.1.2.0.1 Amaliyot Modellari

Amaliyot modellari har qanday dasturiy ta'minot sistemalarini simulyatsiya (harakatga keltirish) jarayonida asosiy o'rin egallaydi. Har qanday amamiyot qanchalik sodda yoki murakkab bo'lmasin, bu amaliyot muvaffaqiyatli simulyatsiya jarayoni ishga tushirilishi kerakligini taqazo qiladi. Ba'zi maktablarda talabalar ro'yxatdan o'tish jarayonini soddalashtirishga harakat qilyapmiz deb o'ylaylik. Ro'yxatga olish jarayoni kompyuter dasturiga talaba ma'lumotini kiritish jarayonini shakllantirishimiz kerak. 

Amaliyot modellari maktab boshqaruv sistemasiga talabalarning ma'lumotini saqlash va kiritish uchun API/UI orqali butun jarayonni taqdim etish, ishlov berish va tashqi texnologiyada saqlashga imkon beradi.

Me'yor amaliyot modellariga katta e'tibor qaratgan chunki aynan ular biznes g'oya jihatdan har qanday sistemaning asosini tashkil qiladi. Dasturni ishlab chiqish va loyihalash davrida, aynan amaliyot modellari ko'plab manba va harakat talab qiladi. Ularni uch turga bo'lish mumkin: tashqi texnologiya bilan aloqa qiluvchi (integratsion), ishlov beruvchi va taqdim qiluvchi. 

#### 0.1.2.0.1.0 Tashqi Texnologiya bilan Bog'lanadigan Modellar (Integratsion yoki broker modeller)

Integratsion amaliyot modellarining asosiy vazifasi mavjud sistemani tashqi manbaalar bilan bog'lashdir. Bunga sistemaga notanish bo'lgan vaqt qiymatini mahalliylashtirish uchun ishlatiladigan vaqtni qaytaruvchi amaliyot modeli yoki tashqi API yoki ma'lumotlar ombori bilan bog'lanadigan modellarni misol qilb keltirishimiz mumkin. 

Biz bu integratsion modellarni "brokerlar" (dallol) deb ataymiz. Ular amaliyot modellari va tashqi sistemalarni bog'lashga xizmat qiliadi. Quyidagi misolga e'tiboringizni qarating: 

``` cs
public partial class ApiBroker
{
	public async ValueTask<Student> PostStudentAsync(Student student) =>
		this.apiBroker.PostAsync<Student>(student, url);
}
```

Tepada ko'rsatilgan integratsion model tashqi API ni chaqirish imkoniyatini beradi. Shu vaqtning o'zi amaliyot modellari tashqi API bilan bog'lanish uchun sozlamalardan xabardor bo'lishlari shart emas. Bu vazifani integratsion model o'z bo'yniga oladi. 

Boshqa amaliyot modellari kabi, ular ham hech qanday ma'lumot o'zi bilan tashimaydi, aksincha ichki va tashqariga taqdim qilinadigan metodlari uchun konstanta yoki ichki qiymatlardan foydalanadi. `ApiBroker` model sifatida tashqi sistemalar bilan bog'lanish jarayonini namoyish qiladi. 

Har qanday tashqi manba yoki sistema bilan aloqa qila oladigan brokerlar yaratish qoidalari va maslahatlar haqida kelgusi boblarimizda batafsil gaplashib o'tamiz. 

#### 0.1.2.0.1.1 Ishlov Berish Modellari (Servislar)

Ishlov berish modellari barcha biznes-g'oyaga bog'liq simulyatsiya jarayonlarini egasidir. Talabani ro'yxatdan o'tkazish, yangi kutubxona obuna kartasini so'rovini yaratish yoki bir talaba ma'lumotlarini ma'lum mezonga asoslanib o'qish amaliyotlari bunga misol bo'lishi mumkin. Ishlov berish modellari quyidagi turlarga bo'linadi: sodda (asos), yuqori-mantiqli (ishlov beruvchi), yoki murakkab (boshqaruvchi).

Ishlov berish modellari odatda o'z-o'ziga (hisoblab servislari kabi), integratsion modellarga yoki bir-biriga bog'liq bo'lishi mumkin. 

Quyida sodda (asos) servisiga misolni ko'rishingiz mumkin: 

```cs 
public partial class StudentService : IStudentService
{
	private readonly IStorageBroker storageBroker;
	...

	public async ValueTask<Student> AddStudentAsync(Student student) =>
		await this.storageBroker.InsertStudentAsync(student);
}
```

Yuqori-mantiqli (ishlov beruvchi) servis quyidagicha bo'ladi: 
```cs
public partial class StudentProcessingService : IStudentProcessingService
{
	private readonly IStudentService studentService;
	...

	public async ValueTask<Student> UpsertStudentAsync(Student student)
	{
		....

		Student maybeStudent = await this.studentService
			.RetrieveStudentByIdAsync(student.Id);
		
		return maybeStudent switch
		{
			null => await this.studentService.AddStudentAsync(student),
			_ => await this.studentService.ModifyStudentAsync(student)
		}
	}
}
```

Murakkabroq (boshqaruvchi) servislar bir nechta yuqori-mantiqli (ishlov beruvchi) yoki sodda (asos) servislari orasida mantiqni boshqaradi:
```cs
public partial class StudentOrchestrationService : IStudentOrchestrationService
{
	private readonly IStudentProcessingService studentProcessingService;
	private readonly IStudentLibraryCardProcessingService studentLibraryCardProcessingService;
	...

	public async ValueTask<Student> RegisterStudentAsync(Student student)
	{
		....
		Student upsertedStudent = await this.studentProcessingService
			.UpsertStudentAsync(student);

		...

		await this.studentLibraryCardProcessingService.AddStudentLibraryCardAsync(studentLibraryCard);
	}
}
```

Odatda, amaliyot modellari ma'lumot tashuvchi modellar ustida bo'ladigan ishlov berish yoki simulyatsiya jarayorini ma'suldir. Ular ma'lumotni ushlab turish yoki holatini saqlab turish vazifasini bajarmaydi. Ko'p hollarda, amaliyot bajaruvchi modellar holatni saqlab qolmaydi. Aksincha, bu ishni loglash yoki loglar (dastur jurnalini yuritish) yoki kuzatish brokerlariga o'tkazib berishadi. 

#### 0.1.2.0.1.2 Taqdimot Modellar (Taqdim Etuvchilar)

Taqdimot modellari Inson-Kompyuter Muloqoti jarayoning barcha jihatlarini qamrab oladi. Ular RESTful API, SDK, Veb-Sahifa yoki terminal/qora oyna kabi kompyuter dasturlari ko'rinishida bo'lishi mumkin. 

Taqdim etuvchi amaliyot modellari integratsion modellarga o'xshab, tashqi dunyo va sizning sistemangiz o'rtasida ko'priq vazifasini o'taydi. Ular sistemaning tashqi qavat tomonda turib, tashqaridan kelayotgan so'rovni qabul qilib unga mos keluvchi amaliyot modeliga uzatadi. Taqdim etuvchi modellar hech qachon integratsion modellar bilan to'g'ridan-to'gri aloqa qilmaydi yoki hech qanday sozlamarni o'zida saqlamaydi. Ular faqatgina konstruktor orqali ular bog'liq bo'lgan klasslarnigina qabul qilib olishi mumkin.

Taqdim etuvchi modellar ishlash jarayonida o'zining tiliga ega bo'lishi mumkin. Misol uchun, integratsion model TalabaJoylash (`InsertStudent`) tilidan foydalansa, xuddi shu API imkoniyatini taqdim etuvchi model TalabaYuklash (`PostStudent`) so'zlarini ishlatishi mumkin.

Quyida taqdim etuvchi modelga misol ko'rishingiz mumkin: 

``` cs
public class StudentsController
{
	private readonly IStudentOrchestrationService studentOrchestrationService;

	[HttpPost]
	public async ValueTask<ActionResult<Student>> PostStudentAsync(Student student)
	{
		Student registeredStudent = await this.studentOrchestrationService
			.RegisterStudentAsync(student);

		return Ok(registeredStudent);
	}
}
```

Tepada ko'rsatilgan model talaba ma'lumotlarini maktab boshqarish sistemasida saqlash uchun API imkoniyatini RESTful aloqa protokoli orqali taqdim etadi. Taqdim etuvchi modellar haqida keyingi bo'limlarda batafsil gaplashib o'tamiz.

### 0.1.2.0.2 Sozlama Modellari

Har qanday sistemada uchrashi mumkin bo'lgan modellarning eng oxirgi turi bu - sozlama modellari. Sistemaga kirish, uning bog'liq klasslarini ro'yxatdan o'tkazish yoki o'rtakash (midleveyr) ko'rinishida havolalarni taqdimot modelidagi u mos bo'lgan funksiyalarga to'g'rilash kabi vazifalarni o'z bo'yniga oladi. 

Sozlama modellari odatda dasturni ishga tushirish jarayonining boshida - kiruvchi va chiquvchi so'rovlar, xotira keshlash, boshqarish va shu kabi ichki sistema amaliyotlarini tartibga soladi.


Sodda API loyihasida, quyidagicha modelga duch kelishingiz mumkin: 

```cs
public class Startup
{
	public void ConfigureServices(IServices services)
	{
		services.AddTransient<IStorageBroker, StorageBroker>();
		services.AddOAuth();
	}	
}
```

As you can see from the code snippet above, the configuration model Startup offers capabilities to handle dependency injection-based registration of contracts to their concrete implementations. They may handle adding security or setting up a middleware pipeline. Configuration models are technology-specific. They may differ from a Play framework in Scala to a Spring or Flex in Python or Java. We will outline high-level rules according to The Standard for configuration models, but we will not dive deeper into the details of implementing any of them.

Tepadagi kod parchasiga binoan, `Startup` deb nomlanuvchi sozlama modeli klasslarning shartnomasini ularning ijrosi bilan bog'lash imkoniyatini taqdim qiladi. Sozlama modellar ma'lum texnologiyaga bog'liq bo'ladi. Ular `Play` nomlanuvchi `Scala` tilining freymvorkida boshqacha yoki `Python` yoki `Java` dagi `Flex` yoki `Spring`larda butunlay boshqacha bo'lishi mumkin. 

## 0.1.3 Simulation

Loyihalar yaratishda, simulyatsiya jarayoni modellarga va ular bilan bog'liq amaliyotlarni ko'rsata olish qobiliyatidir. Oziq-ovqat do'koni misolida, mahsulotni sotish amaliyoti simulyatsiya bo'ladi. Ya'ni, sotish o'z ichida qolgan mahsulatlardan sotilgan mahsulotlar sonini ayirish, shuningdek qolgan mahsulotlarni qiymatiga qarab saralash ishlarini o'z ichiga oladi. 

We can describe the simulation process as illustrating the relationships between models, which are programmed as functions, methods, or routines; these terms all mean the same thing. If we have a software service that is responsible for items sales, a simulation process will look like this:


Simulyatsiya jarayonini modellar orasidagi munosabat ko'rinishida tasvirlashimiz mumkin, ular dasturlashda funksiya, metod yoki "harakat yo'llari" kabi so'zlar bilan ifodalanishi mumkin, lekin bir xil ma'no anglatadi. Mahsulotlar savdosiga mas'ul service yozganimizda, simulyatsiya jarayoni quyidagicha bo'lar edi:

``` cs
public class SaleService
{
	public void Sell(Item item) => Items.Remove(item);
}
```

Yoqorida ko'rsatilgan misolda, mahsulot (item) ustida hatimizdagi sotuv amaliyotini namoyish qiluvchi SaleService (SavdoServis)ni ko'rishingiz mumkin. Aynan shu tarzda har qanday amaliyotni obyektga yo'naltirilgan dasturlash yordamida ifodalaysiz. Hammasi obyektdir (model mahsuli) va ular bir-biri bilan aloqa qiladi.

Object interaction, in general, can be observed in three different types. A model is taking an action on another model. For instance, the SaleService is executing an action of Sell on an Item model. That's a model interacting with another model. In the very same example, a simulation could be something happening to the model from another model, such as the Item in the example above. And the last type of simulation is a model interacting with itself, such as models that self-dispose once their purpose is achieved, as they are no longer needed, so they self-destruct.

Obyekt aloqasi, umuman olib qaraganda, uch xil holatda kuzatilishi mumkin. Bir model boshqa model ustida amal olib borishi. Misol uchun, SavdoServisi (SellServis) sotish  (Sell) amalini mahsulot ustida olib boryapti. Bu bir modelning ikkinchi model ustida amaliyot bajarishiga misol bo'ladi. Xuddi shu misolda, mahsulot (item) nuqata-i nazaridan qaralsa tashqi model uning ustida amaliyot bajaryapti. Va niyohat, kerak bo'lmaganda o'z-o'zini yo'q qila olish ham simulyatsiyaning eng oxirgi bosqichi.

The simulation process is the third and last aspect of software engineering. We will dive into it deeply when we talk about brokers, services, and exposers to illustrate how the industrial software's modeling and simulation process happens.

Loyihalar yaratishning eng oxirgi bosqichi bu simulyatisya jarayonidir. Dasturlash sanoatida loyihalarni modellashtirish va simulyatsiya qilish jarayonlari haqida batafsil brokerlar, servislar va taqdim etuvchilar haqida gaplashganimizda chuqurroq to'xtalib o'tamiz. 


## 0.1.4 Xulosa

Agar maqsadni modellar muloqot qilish asosi deb oladigan bo'lsak, quyidagi tasvir buni yanada aniqlashtirib berishi mumkin:

![Theory Diagram](Resurslar/Maqsad%2C%20Modellashtirish%20va%20Simulyatsiya/0.1.4.png)

Bir narsani anglash muhim: kompyuter dasturlari bir necha maqsadga ega bo'lishi mumkin. Kompyuter dasturi boshqa dasturlar bilan aloqa qilishi va umumiy maqsad sari ishlashi ham mumkin. Shunda, shu loyihalaning maqsadi model ko'rinishida aks etadi va integratsiya (bog'lanish) simulyatsiyani tashkil qiladi. Quyida yuqoridan nazarni ko'rishingiz mumkin:


![Theory Diagram](Resurslar/Maqsad%2C%20Modellashtirish%20va%20Simulyatsiya/0.1.4.1.png)


Har qanday kattalikdagi sistemalarning murakkabligi kichikroq muammolarga bo'linishi mumkin agarda yagona maqsad (vazifa) prinsipi har bir kichik sistemaga qo'llanilsa. Bu zamonaviy arxitektura tili bilan aytganda modullanish yoki bo'laklarga bo'lina olishlik degani. Me'yorning arxitekturaga aloqador qismida aynan shuni muhokama qilamiz. 


[Maqsad, Modellashtirish va Simulyatsiya [Ingliz Tilida]](https://www.youtube.com/watch?v=Doul1gZKCuU "English")


